# Ecommerce Example

Multi-feature BDD test example demonstrating step libraries, codegen, and
cross-feature tag filtering in moonspec.

## What This Example Shows

- **Step libraries**: Splitting step definitions across `CartSteps`,
  `CheckoutSteps`, and `InventorySteps`, each implementing `@moonspec.StepLibrary`
- **World composition**: A single `EcomWorld` struct that wires all three
  libraries together via `use_library`
- **Codegen (PerScenario mode)**: Generated tests in `*_feature_wbtest.mbt`
  — one `async test` per scenario
- **Programmatic tests**: A single test that loads all three feature files
  via multiple `FeatureSource::File` entries
- **Cross-feature tag filtering**: `@smoke` and `not @inventory` across
  feature boundaries

## Project Structure

```
ecommerce/
├── moon.mod.json
├── moonspec.json5                    # Codegen config: world=EcomWorld, mode=per-scenario
├── features/
│   ├── cart.feature                  # 3 scenarios (@cart, @smoke on one)
│   ├── checkout.feature              # 2 scenarios (@checkout, @smoke on one)
│   └── inventory.feature             # 2 scenarios (@inventory, @smoke on one)
└── src/
    ├── world.mbt                     # EcomWorld + World impl
    ├── cart_steps.mbt                # CartSteps: StepLibrary impl
    ├── checkout_steps.mbt            # CheckoutSteps: StepLibrary impl
    ├── inventory_steps.mbt           # InventorySteps: StepLibrary impl
    ├── cart_feature_wbtest.mbt       # Generated: one test per cart scenario
    ├── checkout_feature_wbtest.mbt   # Generated: one test per checkout scenario
    ├── inventory_feature_wbtest.mbt  # Generated: one test per inventory scenario
    └── multi_feature_wbtest.mbt      # Programmatic: all features + tag filtering
```

## World Composition

`EcomWorld` holds shared state for all three domains and registers the step
libraries in `register_steps`:

```moonbit
struct EcomWorld {
  cart : Array[CartItem]
  mut order_total : Int
  mut checkout_rejected : Bool
  inventory : Map[String, Int]
  mut last_checked_item : String
} derive(Default)

impl @moonspec.World for EcomWorld with register_steps(self, s) {
  s.use_library(CartSteps::new(self))
  s.use_library(CheckoutSteps::new(self))
  s.use_library(InventorySteps::new(self))
}
```

Each `StepLibrary` receives a reference to the shared world, so mutations made
by one library (e.g. `CheckoutSteps` clearing the cart) are visible to others.

## Two Testing Approaches

### Codegen (PerScenario)

`moonspec.json5` configures codegen to emit one `async test` per scenario:

```json5
{
  "world": "EcomWorld",
  "mode": "per-scenario"
}
```

The generated files look like:

```moonbit
// Generated by moonspec codegen — DO NOT EDIT
// Source: features/cart.feature

async test "Feature: Shopping Cart / Scenario: Add a single item to the cart" {
  @moonspec.run_or_fail(
    EcomWorld::default,
    [@moonspec.FeatureSource::File("features/cart.feature")],
    scenario_name="Add a single item to the cart",
  )
  |> ignore
}
```

Each test loads its feature file and runs exactly one scenario, giving
individual pass/fail visibility in the test runner.

### Programmatic (multiple FeatureSource)

`multi_feature_wbtest.mbt` loads all three features in a single `run` call:

```moonbit
async test "ecommerce: all features via run_or_fail" {
  @moonspec.run_or_fail(
    EcomWorld::default,
    [
      @moonspec.FeatureSource::File("features/cart.feature"),
      @moonspec.FeatureSource::File("features/checkout.feature"),
      @moonspec.FeatureSource::File("features/inventory.feature"),
    ],
  )
  |> ignore
}
```

## Cross-Feature Tag Filtering

Tag expressions work across all features passed to a single `run` call. The
`@smoke` tag is applied to one scenario in each feature file (3 total):

```moonbit
async test "ecommerce: cross-feature @smoke tag filtering" {
  let result = @moonspec.run(
    EcomWorld::default,
    [
      @moonspec.FeatureSource::File("features/cart.feature"),
      @moonspec.FeatureSource::File("features/checkout.feature"),
      @moonspec.FeatureSource::File("features/inventory.feature"),
    ],
    tag_expr="@smoke",
  )
  assert_eq(result.summary.total_scenarios, 3)
  assert_eq(result.summary.passed, 3)
}
```

Tag exclusion works the same way. The `@inventory` tag on the Inventory feature
lets you exclude those scenarios entirely:

```moonbit
tag_expr="not @inventory"  // runs cart (3) + checkout (2) = 5 scenarios
```

## Running

```bash
moon test --target js
```

Expected output:

```
Total tests: 10, passed: 10, failed: 0.
```
