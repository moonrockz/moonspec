# Calculator Example

End-to-end example of using moonspec to BDD-test a calculator in MoonBit.

## Prerequisites

- [MoonBit toolchain](https://www.moonbitlang.com/download/)
- Node.js (for `moon test --target js` with async tests)
- moonspec CLI: `moon install moonrockz/moonspec/src/cmd/main`

## Project Structure

```
calculator/
├── moon.mod.json              # Project config with moonspec dependency
├── features/
│   └── calculator.feature     # Gherkin feature specification
├── src/
│   ├── moon.pkg.json          # Package imports + pre-build codegen config
│   ├── world.mbt              # World struct + step definitions
│   └── calculator_wbtest.mbt  # Tests using the Runner API
└── README.md
```

## Step-by-Step Walkthrough

### 1. Create a new MoonBit project

```bash
mkdir calculator && cd calculator
moon new
```

### 2. Add moonspec as a dependency

```bash
moon add moonrockz/moonspec
```

This adds moonspec to your `moon.mod.json`. You also need `moonbitlang/async` for
async test support:

```bash
moon add moonbitlang/async
```

### 3. Install the moonspec CLI

```bash
moon install moonrockz/moonspec/src/cmd/main
```

This installs the `moonspec` binary globally so it can be used from the command
line and in pre-build steps.

### 4. Write a feature file

Create `features/calculator.feature`:

```gherkin
Feature: Calculator

  Background:
    Given a calculator

  Scenario: Addition
    When I add 5 and 3
    Then the result should be 8

  Scenario: Subtraction
    When I subtract 3 from 10
    Then the result should be 7

  @slow
  Scenario Outline: Multiplication
    When I multiply <a> and <b>
    Then the result should be <result>

    Examples:
      | a  | b  | result |
      | 2  | 3  | 6      |
      | 10 | 5  | 50     |
```

### 5. Configure pre-build codegen

Add a `pre-build` section to your `src/moon.pkg.json` so that `moonspec gen`
runs automatically before every build or test:

```json
{
  "import": [
    "moonrockz/moonspec",
    "moonbitlang/async"
  ],
  "pre-build": [
    {
      "input": "../features/calculator.feature",
      "output": "calculator_feature_test.mbt",
      "command": "moonspec gen features/calculator.feature -o src/"
    }
  ]
}
```

When you run `moon check`, `moon build`, or `moon test`, the pre-build step
automatically generates `src/calculator_feature_test.mbt` containing test
skeletons for every scenario:

```moonbit
// Generated by moonspec codegen — DO NOT EDIT
// Source: features/calculator.feature

async test "Feature: Calculator / Scenario: Addition" {
  // When I add 5 and 3
  // Then the result should be 8
  ignore("")
}
// ...one test per scenario/outline row
```

Edit your `.feature` files and the generated tests update automatically on the
next build. The generated file is gitignored -- your `.feature` files are the
single source of truth.

### 6. Define your World

Create `src/world.mbt`. The World struct holds per-scenario state and uses
`derive(Default)` for zero-initialization:

```moonbit
struct CalcWorld {
  mut result : Int
} derive(Default)

impl @moonspec.World for CalcWorld with register_steps(self, s) {
  s.given("a calculator", fn(_args) { self.result = 0 })
  s.when("I add {int} and {int}", fn(args) {
    match (args[0], args[1]) {
      (@moonspec.StepArg::IntArg(a), @moonspec.StepArg::IntArg(b)) =>
        self.result = a + b
      _ => ()
    }
  })
  s.then("the result should be {int}", fn(args) raise {
    match args[0] {
      @moonspec.StepArg::IntArg(expected) => assert_eq(self.result, expected)
      _ => ()
    }
  })
}
```

Each scenario gets a fresh `CalcWorld` instance -- state never leaks between scenarios.

### 7. Write tests using the Runner API

Create `src/calculator_wbtest.mbt` to run your feature files through the
moonspec runner with full step matching:

```moonbit
async test "calculator: runner API" {
  let feature =
    #|Feature: Calculator
    #|
    #|  Background:
    #|    Given a calculator
    #|
    #|  Scenario: Addition
    #|    When I add 5 and 3
    #|    Then the result should be 8
  let result = @moonspec.run(CalcWorld::default, [feature])
  assert_eq(result.summary.passed, 1)
  assert_eq(result.summary.failed, 0)
}
```

The Runner API gives you programmatic access to results, tag filtering, and
parallel execution -- complementing the pre-build generated skeletons.

### 8. Run the tests

```bash
# Async tests require the JS target
moon test --target js
```

Expected output:

```
Total tests: 10, passed: 10, failed: 0.
```

### 9. Validate feature files

Use the moonspec CLI to check your feature files for syntax errors:

```bash
moonspec check features/calculator.feature
```

## What This Example Demonstrates

- **Pre-build codegen**: `moonspec gen` runs automatically via `pre-build` in `moon.pkg.json`
- **World trait**: Per-scenario state isolation via `derive(Default)` + `@moonspec.World`
- **Cucumber Expressions**: Type-safe step matching with `{int}` parameters
- **Background steps**: Shared setup (`Given a calculator`) before each scenario
- **Scenario Outlines**: Parameterized tests from Examples tables
- **Tag filtering**: Running only `@slow`-tagged scenarios
- **Runner API**: Programmatic test execution with inline feature content
