# Calculator Example

End-to-end example of using moonspec to BDD-test a calculator in MoonBit.

## Prerequisites

- [MoonBit toolchain](https://www.moonbitlang.com/download/)
- Node.js (for `moon test --target js` with async tests)
- moonspec CLI: `moon install moonrockz/moonspec/src/cmd/main`

## Project Structure

```
calculator/
├── moon.mod.json              # Project config with moonspec dependency
├── features/
│   └── calculator.feature     # Gherkin feature specification
├── src/
│   ├── moon.pkg.json          # Package imports
│   ├── world.mbt              # World struct + step definitions
│   ├── calculator_feature_wbtest.mbt  # Generated tests (moonspec gen)
│   └── calculator_wbtest.mbt  # Tests using the Runner API
└── README.md
```

## Step-by-Step Walkthrough

### 1. Create a new MoonBit project

```bash
mkdir calculator && cd calculator
moon new
```

### 2. Add moonspec as a dependency

```bash
moon add moonrockz/moonspec
```

This adds moonspec to your `moon.mod.json`. You also need `moonbitlang/async` for
async test support:

```bash
moon add moonbitlang/async
```

### 3. Install the moonspec CLI

```bash
moon install moonrockz/moonspec/src/cmd/main
```

This installs the `moonspec` binary globally so it can be used from the command
line and in pre-build steps.

### 4. Write a feature file

Create `features/calculator.feature`:

```gherkin
Feature: Calculator

  Background:
    Given a calculator

  Scenario: Addition
    When I add 5 and 3
    Then the result should be 8

  Scenario: Subtraction
    When I subtract 3 from 10
    Then the result should be 7

  @slow
  Scenario Outline: Multiplication
    When I multiply <a> and <b>
    Then the result should be <result>

    Examples:
      | a  | b  | result |
      | 2  | 3  | 6      |
      | 10 | 5  | 50     |
```

### 5. Generate test files

Run `moonspec gen tests` to generate test files from your `.feature` files. The
`--world` (`-w`) flag specifies the World type that holds step definitions:

```bash
moonspec gen tests features/calculator.feature -w CalcWorld -o src/
```

This generates `src/calculator_feature_wbtest.mbt` containing one `async test` per
scenario that calls `@moonspec.run_or_fail` with `FeatureSource::File`:

```moonbit
// Generated by moonspec codegen — DO NOT EDIT
// Source: features/calculator.feature
// moonspec:hash:6a7ef305

async test "Feature: Calculator / Scenario: Addition" {
  @moonspec.run_or_fail(
    CalcWorld::default,
    [@moonspec.FeatureSource::File("features/calculator.feature")],
    scenario_name="Addition",
  )
  |> ignore
}

async test "Feature: Calculator / Scenario: Subtraction" {
  @moonspec.run_or_fail(
    CalcWorld::default,
    [@moonspec.FeatureSource::File("features/calculator.feature")],
    scenario_name="Subtraction",
  )
  |> ignore
}
// ...one test per scenario/outline row
```

Each generated test loads the `.feature` file at runtime and runs a single scenario
through the full runner pipeline (parsing, pickle compilation, step matching, and
execution).

You can also configure this as a **pre-build step** in `src/moon.pkg.json` so tests
are regenerated automatically on every build:

```json
{
  "import": [
    "moonrockz/moonspec",
    "moonbitlang/async"
  ],
  "pre-build": [
    {
      "input": "../features/calculator.feature",
      "output": "calculator_feature_wbtest.mbt",
      "command": "moonspec gen tests features/calculator.feature -w CalcWorld -o src/"
    }
  ]
}
```

Edit your `.feature` files and the generated tests update automatically on the
next build.

### 6. Define your World

Create `src/world.mbt`. The World struct holds per-scenario state and uses
`derive(Default)` for zero-initialization:

```moonbit
struct CalcWorld {
  mut result : Int
} derive(Default)

impl @moonspec.World for CalcWorld with configure(self, setup) {
  setup.given("a calculator", fn(_args) { self.result = 0 })
  setup.when("I add {int} and {int}", fn(args) {
    match (args[0], args[1]) {
      (@moonspec.StepArg::IntArg(a), @moonspec.StepArg::IntArg(b)) =>
        self.result = a + b
      _ => ()
    }
  })
  setup.then("the result should be {int}", fn(args) raise {
    match args[0] {
      @moonspec.StepArg::IntArg(expected) => assert_eq(self.result, expected)
      _ => ()
    }
  })
}
```

Each scenario gets a fresh `CalcWorld` instance -- state never leaks between scenarios.

### 7. Write tests using the Runner API

Create `src/calculator_wbtest.mbt` to run your feature files through the
moonspec runner with full step matching:

```moonbit
async test "calculator: runner API" {
  let feature =
    #|Feature: Calculator
    #|
    #|  Background:
    #|    Given a calculator
    #|
    #|  Scenario: Addition
    #|    When I add 5 and 3
    #|    Then the result should be 8
  @moonspec.run_or_fail(
    CalcWorld::default,
    [@moonspec.FeatureSource::Text("test://calculator", feature)],
  )
  |> ignore
}
```

For programmatic access to results (e.g. tag filtering, inspecting pass/fail
counts), use `@moonspec.run` instead:

```moonbit
async test "calculator: tag filtering" {
  let result = @moonspec.run(
    CalcWorld::default,
    [@moonspec.FeatureSource::File("features/calculator.feature")],
    tags="not @slow",
  )
  assert_eq(result.summary.failed, 0)
}
```

The Runner API gives you programmatic access to results, tag filtering, and
parallel execution -- complementing the generated tests.

### 8. Run the tests

```bash
# Async tests require the JS target
moon test --target js
```

Expected output:

```
Total tests: 6, passed: 6, failed: 0.
```

### 9. Validate feature files

Use the moonspec CLI to check your feature files for syntax errors:

```bash
moonspec check features/calculator.feature
```

## What This Example Demonstrates

- **Codegen**: `moonspec gen tests -w CalcWorld` generates runner tests from `.feature` files
- **World trait**: Per-scenario state isolation via `derive(Default)` + `@moonspec.World`
- **Cucumber Expressions**: Type-safe step matching with `{int}` parameters
- **Background steps**: Shared setup (`Given a calculator`) before each scenario
- **Scenario Outlines**: Parameterized tests from Examples tables
- **Tag filtering**: Running only `@slow`-tagged scenarios
- **Runner API**: Programmatic test execution with inline feature content
- **run_or_fail**: Throwing variant that fails the test on any step failure
- **Structured errors**: `MoonspecError` hierarchy for parse, undefined step, and execution errors
