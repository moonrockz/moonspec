// Generated using `moon info`, DON'T EDIT IT
package "moonrockz/moonspec/runner"

import {
  "moonrockz/cucumber-messages",
  "moonrockz/gherkin",
  "moonrockz/moonspec/core",
}

// Values
pub fn build_step_definition_envelopes(@core.StepRegistry) -> Array[@cucumber-messages.Envelope]

pub fn build_test_cases(@core.StepRegistry, Array[@cucumber-messages.Pickle], IdGenerator) -> Array[@cucumber-messages.Envelope]

pub fn compile_pickles(FeatureCache) -> Array[@cucumber-messages.Pickle]

pub fn execute_scenario(@core.StepRegistry, feature_name~ : String, scenario_name~ : String, pickle_id~ : String, tags~ : Array[String], steps~ : Array[@cucumber-messages.PickleStep], sinks? : Array[&@core.MessageSink], test_case_started_id? : String, test_step_ids? : Array[String]) -> ScenarioResult

pub fn[W : @core.Hooks] execute_scenario_with_hooks(W, @core.StepRegistry, feature_name~ : String, scenario_name~ : String, pickle_id~ : String, tags~ : Array[String], steps~ : Array[@cucumber-messages.PickleStep], sinks? : Array[&@core.MessageSink], test_case_started_id? : String, test_step_ids? : Array[String]) -> ScenarioResult

pub async fn[W : @core.World] run(() -> W, Array[FeatureSource], tag_expr? : String, scenario_name? : String, parallel? : Int, sinks? : Array[&@core.MessageSink]) -> RunResult

pub async fn[W : @core.World] run_or_fail(() -> W, Array[FeatureSource], tag_expr? : String, scenario_name? : String, parallel? : Int, sinks? : Array[&@core.MessageSink]) -> RunResult

pub async fn[W : @core.World + @core.Hooks] run_with_hooks(() -> W, Array[FeatureSource], tag_expr? : String, scenario_name? : String, parallel? : Int, sinks? : Array[&@core.MessageSink]) -> RunResult

// Errors

// Types and methods
pub(all) struct CollectorSink {
  envelopes : Array[@cucumber-messages.Envelope]
}
pub fn CollectorSink::new() -> Self
pub impl @core.MessageSink for CollectorSink

pub struct FeatureCache {
  // private fields
}
pub fn FeatureCache::contains(Self, String) -> Bool
pub fn FeatureCache::features(Self) -> Array[(String, @gherkin.Feature)]
pub fn FeatureCache::get(Self, String) -> @gherkin.Feature?
pub fn FeatureCache::length(Self) -> Int
pub fn FeatureCache::load_file(Self, String) -> Unit raise
pub fn FeatureCache::load_from_source(Self, FeatureSource) -> Array[ParseErrorInfo]
pub fn FeatureCache::load_parsed(Self, String, @gherkin.Feature) -> Unit
pub fn FeatureCache::load_text(Self, String, String) -> Unit raise
pub fn FeatureCache::new() -> Self

pub(all) struct FeatureResult {
  name : String
  scenarios : Array[ScenarioResult]
  duration_ms : Int64
}
pub impl Show for FeatureResult

pub(all) enum FeatureSource {
  Text(String, String)
  File(String)
  Parsed(String, @gherkin.Feature)
}
pub impl Eq for FeatureSource
pub impl Show for FeatureSource

pub(all) struct IdGenerator {
  // private fields
}
pub fn IdGenerator::new() -> Self
pub fn IdGenerator::next(Self, String) -> String

pub(all) struct ParseErrorInfo {
  uri : String
  message : String
  line : Int?
}
pub impl Eq for ParseErrorInfo
pub impl Show for ParseErrorInfo

pub struct PickleFilter {
  tag_expression : TagExpression
  scenario_names : Array[String]
}
pub fn PickleFilter::apply(Self, Array[@cucumber-messages.Pickle]) -> Array[@cucumber-messages.Pickle]
pub fn PickleFilter::new() -> Self
pub fn PickleFilter::with_names(Self, Array[String]) -> Self
pub fn PickleFilter::with_tags(Self, String) -> Self raise

pub(all) struct RunResult {
  features : Array[FeatureResult]
  summary : RunSummary
  parse_errors : Array[ParseErrorInfo]
}
pub impl Show for RunResult

pub(all) struct RunSummary {
  total_scenarios : Int
  passed : Int
  failed : Int
  undefined : Int
  pending : Int
  skipped : Int
  duration_ms : Int64
}
pub impl Eq for RunSummary
pub impl Show for RunSummary

pub(all) struct ScenarioResult {
  feature_name : String
  scenario_name : String
  pickle_id : String
  tags : Array[String]
  steps : Array[StepResult]
  status : ScenarioStatus
  duration_ms : Int64
}
pub impl Show for ScenarioResult

pub(all) enum ScenarioStatus {
  Passed
  Failed
  Skipped
  Undefined
  Pending
}
pub fn ScenarioStatus::from_steps(Array[StepStatus]) -> Self
pub impl Eq for ScenarioStatus
pub impl Show for ScenarioStatus

pub(all) struct StepResult {
  text : String
  keyword : String
  status : StepStatus
  duration_ms : Int64
  diagnostic : Error?
}
pub impl Show for StepResult

pub(all) enum StepStatus {
  Passed
  Failed(String)
  Skipped
  Undefined
  Pending
}
pub fn StepStatus::is_passed(Self) -> Bool
pub impl Eq for StepStatus
pub impl Show for StepStatus

pub(all) enum TagExpression {
  TagLiteral(String)
  Not(TagExpression)
  And(TagExpression, TagExpression)
  Or(TagExpression, TagExpression)
  Always
}
pub fn TagExpression::matches(Self, Array[String]) -> Bool
pub fn TagExpression::parse(String) -> Self raise
pub impl Eq for TagExpression
pub impl Show for TagExpression

// Type aliases

// Traits

