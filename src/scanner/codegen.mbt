///|
/// Generate a `register_steps` impl block for the given world type and step functions.
pub fn generate_register_steps(
  world_type : String,
  steps : Array[StepFnInfo],
  source_hash~ : String,
) -> String {
  let buf = StringBuilder::new()
  buf.write_string("// Generated by moonspec gen steps â€” DO NOT EDIT\n")
  buf.write_string("// moonspec:hash:" + source_hash + "\n")
  buf.write_string("\n")
  buf.write_string(
    "impl @moonspec.World for " +
    world_type +
    " with register_steps(self, s) {\n",
  )
  for step in steps {
    generate_step_registration(buf, step)
  }
  buf.write_string("}\n")
  buf.to_string()
}

///|
fn generate_step_registration(buf : StringBuilder, step : StepFnInfo) -> Unit {
  buf.write_string(
    "  s." +
    step.keyword +
    "(\"" +
    escape_pattern(step.pattern) +
    "\", fn(args) raise {\n",
  )
  // Generate arg extraction for each param
  for i, param in step.params {
    let idx = i.to_string()
    buf.write_string("    let _arg" + idx + " = ")
    buf.write_string(generate_arg_match(idx, param.type_name))
    buf.write_string("\n")
  }
  // Generate the function call
  buf.write_string("    " + step.fn_name + "(self")
  for i, _param in step.params {
    buf.write_string(", _arg" + i.to_string())
  }
  buf.write_string(")\n")
  buf.write_string("  })\n")
}

///|
fn generate_arg_match(idx : String, type_name : String) -> String {
  if type_name == "Int" {
    "match args[" + idx + "] { IntArg(v) => v; _ => 0 }"
  } else if type_name == "Double" {
    "match args[" + idx + "] { FloatArg(v) => v; _ => 0.0 }"
  } else {
    // String and any other type
    "match args[" +
    idx +
    "] { StringArg(v) => v; WordArg(v) => v; CustomArg(v) => v; _ => \"\" }"
  }
}

///|
fn escape_pattern(s : String) -> String {
  let buf = StringBuilder::new()
  for i = 0; i < s.length(); i = i + 1 {
    let c = s[i]
    if c == '"' {
      buf.write_string("\\\"")
    } else if c == '\\' {
      buf.write_string("\\\\")
    } else {
      buf.write_char(c.to_int().unsafe_to_char())
    }
  }
  buf.to_string()
}
