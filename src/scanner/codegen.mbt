///|
/// Generate a `configure` impl block for the given world type and step functions.
pub fn generate_configure(
  world_type : String,
  steps : Array[StepFnInfo],
  source_hash~ : String,
) -> String {
  let buf = StringBuilder::new()
  buf.write_string("// Generated by moonspec gen steps â€” DO NOT EDIT\n")
  buf.write_string("// moonspec:hash:" + source_hash + "\n")
  buf.write_string("\n")
  buf.write_string(
    "impl @moonspec.World for " +
    world_type +
    " with configure(self, setup) {\n",
  )
  for step in steps {
    generate_step_registration(buf, step)
  }
  buf.write_string("}\n")
  buf.to_string()
}

///|
fn generate_step_registration(buf : StringBuilder, step : StepFnInfo) -> Unit {
  let arity = step.params.length().to_string()
  buf.write_string(
    "  setup." +
    step.keyword +
    arity +
    "(\"" +
    escape_pattern(step.pattern) +
    "\", fn(",
  )
  // Generate typed lambda parameters
  for i, param in step.params {
    if i > 0 {
      buf.write_string(", ")
    }
    buf.write_string("_arg" + i.to_string() + " : " + param.type_name)
  }
  buf.write_string(") {\n")
  // Generate the function call
  buf.write_string("    " + step.fn_name + "(self")
  for i, _param in step.params {
    buf.write_string(", _arg" + i.to_string())
  }
  buf.write_string(")\n")
  buf.write_string("  })\n")
}

///|
fn escape_pattern(s : String) -> String {
  let buf = StringBuilder::new()
  for i = 0; i < s.length(); i = i + 1 {
    let c = s[i]
    if c == '"' {
      buf.write_string("\\\"")
    } else if c == '\\' {
      buf.write_string("\\\\")
    } else {
      buf.write_char(c.to_int().unsafe_to_char())
    }
  }
  buf.to_string()
}
