///|
/// Generate a `configure` impl block for the given world type and step functions.
pub fn generate_configure(
  world_type : String,
  steps : Array[StepFnInfo],
  source_hash~ : String,
) -> String {
  let buf = StringBuilder::new()
  buf.write_string("// Generated by moonspec gen steps — DO NOT EDIT\n")
  buf.write_string("// moonspec:hash:" + source_hash + "\n")
  buf.write_string("\n")
  buf.write_string(
    "impl @moonspec.World for " +
    world_type +
    " with configure(self, setup) {\n",
  )
  for step in steps {
    generate_step_registration(buf, step)
  }
  buf.write_string("}\n")
  buf.to_string()
}

///|
fn generate_step_registration(buf : StringBuilder, step : StepFnInfo) -> Unit {
  let arity = step.params.length()
  if arity <= 22 {
    generate_typed_step(buf, step, arity)
  } else {
    generate_ctx_step(buf, step)
  }
}

///|
/// Generate a typed arity-suffixed step registration (arities 0–22).
fn generate_typed_step(
  buf : StringBuilder,
  step : StepFnInfo,
  arity : Int,
) -> Unit {
  buf.write_string(
    "  setup." +
    step.keyword +
    arity.to_string() +
    "(\"" +
    escape_pattern(step.pattern) +
    "\", fn(",
  )
  for i, param in step.params {
    if i > 0 {
      buf.write_string(", ")
    }
    buf.write_string("_arg" + i.to_string() + " : " + param.type_name)
  }
  buf.write_string(") {\n")
  buf.write_string("    " + step.fn_name + "(self")
  for i, _param in step.params {
    buf.write_string(", _arg" + i.to_string())
  }
  buf.write_string(")\n")
  buf.write_string("  })\n")
}

///|
/// Generate a ctx-based step registration for arities > 22.
fn generate_ctx_step(buf : StringBuilder, step : StepFnInfo) -> Unit {
  buf.write_string(
    "  setup." +
    step.keyword +
    "(\"" +
    escape_pattern(step.pattern) +
    "\", fn(ctx) raise {\n",
  )
  for i, param in step.params {
    let idx = i.to_string()
    buf.write_string("    let _arg" + idx + " = ")
    buf.write_string(generate_arg_match(idx, param.type_name))
    buf.write_string("\n")
  }
  buf.write_string("    " + step.fn_name + "(self")
  for i, _param in step.params {
    buf.write_string(", _arg" + i.to_string())
  }
  buf.write_string(")\n")
  buf.write_string("  })\n")
}

///|
fn generate_arg_match(idx : String, type_name : String) -> String {
  if type_name == "Int" {
    "match ctx[" + idx + "] { { value: IntVal(v), .. } => v; _ => 0 }"
  } else if type_name == "Double" {
    "match ctx[" + idx + "] { { value: FloatVal(v), .. } => v; _ => 0.0 }"
  } else {
    "match ctx[" +
    idx +
    "] { { value: StringVal(v), .. } => v; { value: WordVal(v), .. } => v; _ => \"\" }"
  }
}

///|
fn escape_pattern(s : String) -> String {
  let buf = StringBuilder::new()
  for i = 0; i < s.length(); i = i + 1 {
    let c = s[i]
    if c == '"' {
      buf.write_string("\\\"")
    } else if c == '\\' {
      buf.write_string("\\\\")
    } else {
      buf.write_char(c.to_int().unsafe_to_char())
    }
  }
  buf.to_string()
}
