///|
/// moonspec codegen — Generate _test.mbt from .feature files.
pub fn codegen_version() -> String {
  "0.1.0"
}

///|
/// Simple FNV-1a-like hash of a string, returned as a hex string.
fn simple_hash(s : String) -> String {
  let mut hash : UInt = 2166136261
  for i = 0; i < s.length(); i = i + 1 {
    hash = hash ^ s[i].to_int().reinterpret_as_uint()
    hash = hash * 16777619
  }
  uint_to_hex(hash)
}

///|
/// Convert a UInt to a lowercase hex string.
fn uint_to_hex(n : UInt) -> String {
  let digits = "0123456789abcdef"
  let buf = StringBuilder::new()
  let mut val = n
  let arr : Array[Char] = []
  if val == 0 {
    return "00000000"
  }
  while val > 0 {
    let idx = (val % 16).reinterpret_as_int()
    arr.push(digits[idx].to_int().unsafe_to_char())
    val = val / 16
  }
  while arr.length() < 8 {
    arr.push('0')
  }
  let len = arr.length()
  for i = len - 1; i >= 0; i = i - 1 {
    buf.write_char(arr[i])
  }
  buf.to_string()
}

///|
fn contains(haystack : String, needle : String) -> Bool {
  let h_len = haystack.length()
  let n_len = needle.length()
  if n_len == 0 {
    return true
  }
  if n_len > h_len {
    return false
  }
  for i = 0; i <= h_len - n_len; i = i + 1 {
    let mut found = true
    for j = 0; j < n_len; j = j + 1 {
      if haystack[i + j] != needle[j] {
        found = false
        break
      }
    }
    if found {
      return true
    }
  }
  false
}

///|
fn string_replace(s : String, old : String, new_val : String) -> String {
  let buf = StringBuilder::new()
  let s_len = s.length()
  let old_len = old.length()
  if old_len == 0 {
    return s
  }
  let mut i = 0
  while i < s_len {
    if i + old_len <= s_len {
      let mut matches = true
      for j = 0; j < old_len; j = j + 1 {
        if s[i + j] != old[j] {
          matches = false
          break
        }
      }
      if matches {
        buf.write_string(new_val)
        i = i + old_len
        continue
      }
    }
    buf.write_char(s[i].to_int().unsafe_to_char())
    i = i + 1
  }
  buf.to_string()
}

///|
fn starts_with(s : String, prefix : String) -> Bool {
  let s_len = s.length()
  let p_len = prefix.length()
  if p_len > s_len {
    return false
  }
  for i = 0; i < p_len; i = i + 1 {
    if s[i] != prefix[i] {
      return false
    }
  }
  true
}

///|
fn substring_from(s : String, start : Int) -> String {
  let buf = StringBuilder::new()
  for i = start; i < s.length(); i = i + 1 {
    buf.write_char(s[i].to_int().unsafe_to_char())
  }
  buf.to_string()
}

///|
/// Convert a .feature file path to a _test.mbt filename.
///
/// - Strip "features/" prefix
/// - Replace "/" with "_"
/// - Replace ".feature" with "_feature_test.mbt"
pub fn feature_to_test_filename(path : String) -> String {
  let mut result = path
  if starts_with(result, "features/") {
    result = substring_from(result, 9) // len("features/") == 9
  }
  result = string_replace(result, "/", "_")
  result = string_replace(result, ".feature", "_feature_test.mbt")
  result
}

///|
/// Generate a MoonBit test file from a Gherkin feature file.
///
/// When `config.world` is set, generates real test code that calls
/// `@moonspec.run` with the specified World type. When empty, generates
/// stub tests with `ignore("")` placeholders.
pub fn generate_test_file(
  feature_content : String,
  source_path : String,
  config? : CodegenConfig = CodegenConfig::default(),
) -> String {
  let hash = simple_hash(feature_content)
  let source = @gherkin.Source::from_string(feature_content)
  let doc = @gherkin.parse(source) catch {
    _ =>
      return "// moonspec:hash:" +
        hash +
        "\n// ERROR: Failed to parse " +
        source_path +
        "\n"
  }
  let buf = StringBuilder::new()
  buf.write_string("// Generated by moonspec codegen — DO NOT EDIT\n")
  buf.write_string("// Source: " + source_path + "\n")
  buf.write_string("// moonspec:hash:" + hash + "\n")
  buf.write_string("\n")
  let feature = match doc.feature {
    Some(f) => f
    None => return buf.to_string()
  }
  match config.mode {
    PerFeature => generate_per_feature(buf, feature, source_path, config)
    PerScenario => generate_per_scenario(buf, feature, source_path, config)
  }
  buf.to_string()
}

///|
/// PerFeature mode: single test that reads the feature file from disk.
fn generate_per_feature(
  buf : StringBuilder,
  feature : @gherkin.Feature,
  source_path : String,
  config : CodegenConfig,
) -> Unit {
  let test_name = "Feature: " + feature.name
  buf.write_string("async test \"" + escape_string(test_name) + "\" {\n")
  if config.world.length() > 0 {
    buf.write_string(
      "  @moonspec.run_or_fail(\n    " +
      config.world +
      "::default, [@moonspec.FeatureSource::File(\"" +
      escape_string(source_path) +
      "\")],\n  )\n",
    )
  } else {
    buf.write_string("  ignore(\"\")\n")
  }
  buf.write_string("}\n")
}

///|
/// PerScenario mode: one test per scenario, using File source with scenario_name filter.
fn generate_per_scenario(
  buf : StringBuilder,
  feature : @gherkin.Feature,
  source_path : String,
  config : CodegenConfig,
) -> Unit {
  for child in feature.children {
    match child {
      @gherkin.FeatureChild::Scenario(scenario) =>
        if scenario.examples.is_empty() {
          generate_scenario_runner_test(
            buf,
            feature.name,
            scenario.name,
            source_path,
            config,
          )
          buf.write_string("\n")
        } else {
          for examples in scenario.examples {
            let headers = match examples.table_header {
              Some(header_row) => header_row.cells.map(fn(c) { c.value })
              None => continue
            }
            for row in examples.table_body {
              let values = row.cells.map(fn(c) { c.value })
              let params : Array[String] = []
              for i = 0; i < headers.length(); i = i + 1 {
                params.push(headers[i] + "=" + values[i])
              }
              let scenario_name = scenario.name + " (" + params.join(", ") + ")"
              generate_scenario_runner_test(
                buf,
                feature.name,
                scenario_name,
                source_path,
                config,
              )
              buf.write_string("\n")
            }
          }
        }
      _ => ()
    }
  }
}

///|
/// Generate a single async test that uses File source with scenario_name filter.
fn generate_scenario_runner_test(
  buf : StringBuilder,
  feature_name : String,
  scenario_name : String,
  source_path : String,
  config : CodegenConfig,
) -> Unit {
  let test_name = "Feature: " + feature_name + " / Scenario: " + scenario_name
  buf.write_string("async test \"" + escape_string(test_name) + "\" {\n")
  if config.world.length() > 0 {
    buf.write_string(
      "  @moonspec.run_or_fail(\n    " +
      config.world +
      "::default, [@moonspec.FeatureSource::File(\"" +
      escape_string(source_path) +
      "\")],\n    scenario_name=\"" +
      escape_string(scenario_name) +
      "\",\n  )\n",
    )
  } else {
    buf.write_string("  // Source: " + source_path + "\n")
    buf.write_string("  ignore(\"\")\n")
  }
  buf.write_string("}\n")
}

///|
fn escape_string(s : String) -> String {
  string_replace(s, "\"", "\\\"")
}
