///|
/// Simple FNV-1a-like hash of a string, returned as a hex string.
fn simple_hash(s : String) -> String {
  let mut hash : UInt = 2166136261
  for i = 0; i < s.length(); i = i + 1 {
    hash = hash ^ s[i].to_int().reinterpret_as_uint()
    hash = hash * 16777619
  }
  uint_to_hex(hash)
}

///|
/// Convert a UInt to a lowercase hex string.
fn uint_to_hex(n : UInt) -> String {
  let digits = "0123456789abcdef"
  let buf = StringBuilder::new()
  let mut val = n
  let arr : Array[Char] = []
  if val == 0 {
    return "00000000"
  }
  while val > 0 {
    let idx = (val % 16).reinterpret_as_int()
    arr.push(digits[idx].to_int().unsafe_to_char())
    val = val / 16
  }
  while arr.length() < 8 {
    arr.push('0')
  }
  let len = arr.length()
  for i = len - 1; i >= 0; i = i - 1 {
    buf.write_char(arr[i])
  }
  buf.to_string()
}

///|
fn string_replace(s : String, old : String, new_val : String) -> String {
  let buf = StringBuilder::new()
  let s_len = s.length()
  let old_len = old.length()
  if old_len == 0 {
    return s
  }
  let mut i = 0
  while i < s_len {
    if i + old_len <= s_len {
      let mut matches = true
      for j = 0; j < old_len; j = j + 1 {
        if s[i + j] != old[j] {
          matches = false
          break
        }
      }
      if matches {
        buf.write_string(new_val)
        i = i + old_len
        continue
      }
    }
    buf.write_char(s[i].to_int().unsafe_to_char())
    i = i + 1
  }
  buf.to_string()
}

///|
fn starts_with(s : String, prefix : String) -> Bool {
  let s_len = s.length()
  let p_len = prefix.length()
  if p_len > s_len {
    return false
  }
  for i = 0; i < p_len; i = i + 1 {
    if s[i] != prefix[i] {
      return false
    }
  }
  true
}

///|
fn substring_from(s : String, start : Int) -> String {
  let buf = StringBuilder::new()
  for i = start; i < s.length(); i = i + 1 {
    buf.write_char(s[i].to_int().unsafe_to_char())
  }
  buf.to_string()
}

///|
/// Convert a .feature file path to a _test.mbt filename.
///
/// - Strip "features/" prefix
/// - Replace "/" with "_"
/// - Replace ".feature" with "_feature_test.mbt"
pub fn feature_to_test_filename(path : String) -> String {
  let mut result = path
  if starts_with(result, "features/") {
    result = substring_from(result, 9) // len("features/") == 9
  }
  result = string_replace(result, "/", "_")
  result = string_replace(result, ".feature", "_feature_test.mbt")
  result
}

///|
/// Generate a MoonBit test file from a Gherkin feature file.
///
/// When `config.world` is set, generates real test code that calls
/// `@moonspec.run` with the specified World type. When empty, generates
/// stub tests with `ignore("")` placeholders.
pub fn generate_test_file(
  feature_content : String,
  source_path : String,
  config? : CodegenConfig = CodegenConfig::default(),
) -> String {
  let hash = simple_hash(feature_content)
  let source = @gherkin.Source::from_string(feature_content)
  let doc = @gherkin.parse(source) catch {
    _ =>
      return "// moonspec:hash:" +
        hash +
        "\n// ERROR: Failed to parse " +
        source_path +
        "\n"
  }
  let buf = StringBuilder::new()
  buf.write_string("// Generated by moonspec codegen â€” DO NOT EDIT\n")
  buf.write_string("// Source: " + source_path + "\n")
  buf.write_string("// moonspec:hash:" + hash + "\n")
  buf.write_string("\n")
  let feature = match doc.feature {
    Some(f) => f
    None => return buf.to_string()
  }
  match config.mode {
    PerFeature => generate_per_feature(buf, feature, source_path, config)
    PerScenario => generate_per_scenario(buf, feature, source_path, config)
  }
  buf.to_string()
}

///|
/// PerFeature mode: single test that reads the feature file from disk.
fn generate_per_feature(
  buf : StringBuilder,
  feature : @gherkin.Feature,
  source_path : String,
  config : CodegenConfig,
) -> Unit {
  let test_name = "Feature: " + feature.name
  buf.write_string("async test \"" + escape_string(test_name) + "\" {\n")
  if config.world.length() > 0 {
    buf.write_string(
      "  let options = @moonspec.RunOptions::new([@moonspec.FeatureSource::File(\"" +
      escape_string(source_path) +
      "\")])\n",
    )
    generate_skip_tags_line(buf, config)
    generate_formatter_lines(buf, config)
    buf.write_string(
      "  @moonspec.run_or_fail(\n    " +
      config.world +
      "::default, options,\n  )\n  |> ignore\n",
    )
  } else {
    buf.write_string("  ignore(\"\")\n")
  }
  buf.write_string("}\n")
}

///|
/// PerScenario mode: one test per scenario, using File source with scenario_name filter.
fn generate_per_scenario(
  buf : StringBuilder,
  feature : @gherkin.Feature,
  source_path : String,
  config : CodegenConfig,
) -> Unit {
  for child in feature.children {
    match child {
      @gherkin.FeatureChild::Scenario(scenario) =>
        if scenario.examples.is_empty() {
          generate_scenario_runner_test(
            buf,
            feature.name,
            scenario.name,
            source_path,
            config,
          )
          buf.write_string("\n")
        } else {
          for examples in scenario.examples {
            let headers = match examples.table_header {
              Some(header_row) => header_row.cells.map(fn(c) { c.value })
              None => continue
            }
            for row in examples.table_body {
              let values = row.cells.map(fn(c) { c.value })
              let params : Array[String] = []
              for i = 0; i < headers.length(); i = i + 1 {
                params.push(headers[i] + "=" + values[i])
              }
              let scenario_name = scenario.name + " (" + params.join(", ") + ")"
              generate_scenario_runner_test(
                buf,
                feature.name,
                scenario_name,
                source_path,
                config,
              )
              buf.write_string("\n")
            }
          }
        }
      _ => ()
    }
  }
}

///|
/// Generate a single async test that uses File source with scenario_name filter.
fn generate_scenario_runner_test(
  buf : StringBuilder,
  feature_name : String,
  scenario_name : String,
  source_path : String,
  config : CodegenConfig,
) -> Unit {
  let test_name = "Feature: " + feature_name + " / Scenario: " + scenario_name
  buf.write_string("async test \"" + escape_string(test_name) + "\" {\n")
  if config.world.length() > 0 {
    buf.write_string(
      "  let options = @moonspec.RunOptions::new([@moonspec.FeatureSource::File(\"" +
      escape_string(source_path) +
      "\")])\n  options.scenario_name(\"" +
      escape_string(scenario_name) +
      "\")\n",
    )
    generate_skip_tags_line(buf, config)
    generate_formatter_lines(buf, config)
    buf.write_string(
      "  @moonspec.run_or_fail(\n    " +
      config.world +
      "::default, options,\n  )\n  |> ignore\n",
    )
  } else {
    buf.write_string("  // Source: " + source_path + "\n")
    buf.write_string("  ignore(\"\")\n")
  }
  buf.write_string("}\n")
}

///|
/// Generate `options.skip_tags([...])` line if custom skip tags are configured.
fn generate_skip_tags_line(buf : StringBuilder, config : CodegenConfig) -> Unit {
  match config.skip_tags {
    Some(tags) => {
      buf.write_string("  options.skip_tags([")
      for i, tag in tags {
        if i > 0 {
          buf.write_string(", ")
        }
        buf.write_string("\"" + escape_string(tag) + "\"")
      }
      buf.write_string("])\n")
    }
    None => ()
  }
}

///|
/// Generate `options.add_formatter(...)` lines for configured formatters.
/// When no formatters are configured, generates a default PrettyFormatter on stdout.
fn generate_formatter_lines(
  buf : StringBuilder,
  config : CodegenConfig,
) -> Unit {
  match config.formatters {
    Some(fmts) =>
      for fmt in fmts {
        let ctor = match fmt.type_ {
          "pretty" =>
            if fmt.no_color {
              "@format.PrettyFormatter::new(no_color=true)"
            } else {
              "@format.PrettyFormatter::new()"
            }
          "junit" => "@format.JUnitFormatter::new()"
          "messages" => "@format.MessagesFormatter::new()"
          _ => continue
        }
        let dest = match fmt.output {
          "stdout" => "@moonspec.Stdout"
          "stderr" => "@moonspec.Stderr"
          _ => "@moonspec.File(\"" + escape_string(fmt.output) + "\")"
        }
        buf.write_string(
          "  options.add_formatter(&" + ctor + ", " + dest + ")\n",
        )
      }
    None =>
      // Default: PrettyFormatter on stdout
      buf.write_string(
        "  options.add_formatter(&@format.PrettyFormatter::new(), @moonspec.Stdout)\n",
      )
  }
}

///|
fn escape_string(s : String) -> String {
  string_replace(s, "\"", "\\\"")
}
