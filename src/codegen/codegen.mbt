///|
/// moonspec codegen — Generate _test.mbt from .feature files.
pub fn codegen_version() -> String {
  "0.1.0"
}

///|
/// Simple FNV-1a-like hash of a string, returned as a hex string.
fn simple_hash(s : String) -> String {
  let mut hash : UInt = 2166136261
  for i = 0; i < s.length(); i = i + 1 {
    hash = hash ^ s[i].to_int().reinterpret_as_uint()
    hash = hash * 16777619
  }
  uint_to_hex(hash)
}

///|
/// Convert a UInt to a lowercase hex string.
fn uint_to_hex(n : UInt) -> String {
  let digits = "0123456789abcdef"
  let buf = StringBuilder::new()
  let mut val = n
  // Collect digits in reverse
  let arr : Array[Char] = []
  if val == 0 {
    return "00000000"
  }
  while val > 0 {
    let idx = (val % 16).reinterpret_as_int()
    arr.push(digits[idx].to_int().unsafe_to_char())
    val = val / 16
  }
  // Pad to 8 chars
  while arr.length() < 8 {
    arr.push('0')
  }
  // Reverse
  let len = arr.length()
  for i = len - 1; i >= 0; i = i - 1 {
    buf.write_char(arr[i])
  }
  buf.to_string()
}

///|
/// Check if haystack contains needle as a substring.
fn contains(haystack : String, needle : String) -> Bool {
  let h_len = haystack.length()
  let n_len = needle.length()
  if n_len == 0 {
    return true
  }
  if n_len > h_len {
    return false
  }
  for i = 0; i <= h_len - n_len; i = i + 1 {
    let mut found = true
    for j = 0; j < n_len; j = j + 1 {
      if haystack[i + j] != needle[j] {
        found = false
        break
      }
    }
    if found {
      return true
    }
  }
  false
}

///|
/// Replace all occurrences of `old` with `new_val` in `s`.
fn string_replace(s : String, old : String, new_val : String) -> String {
  let buf = StringBuilder::new()
  let s_len = s.length()
  let old_len = old.length()
  if old_len == 0 {
    return s
  }
  let mut i = 0
  while i < s_len {
    if i + old_len <= s_len {
      let mut matches = true
      for j = 0; j < old_len; j = j + 1 {
        if s[i + j] != old[j] {
          matches = false
          break
        }
      }
      if matches {
        buf.write_string(new_val)
        i = i + old_len
        continue
      }
    }
    buf.write_char(s[i].to_int().unsafe_to_char())
    i = i + 1
  }
  buf.to_string()
}

///|
/// Check if string starts with the given prefix.
fn starts_with(s : String, prefix : String) -> Bool {
  let s_len = s.length()
  let p_len = prefix.length()
  if p_len > s_len {
    return false
  }
  for i = 0; i < p_len; i = i + 1 {
    if s[i] != prefix[i] {
      return false
    }
  }
  true
}

///|
/// Get substring from index `start` to end of string.
fn substring_from(s : String, start : Int) -> String {
  let buf = StringBuilder::new()
  for i = start; i < s.length(); i = i + 1 {
    buf.write_char(s[i].to_int().unsafe_to_char())
  }
  buf.to_string()
}

///|
/// Convert a .feature file path to a _test.mbt filename.
///
/// - Strip "features/" prefix
/// - Replace "/" with "_"
/// - Replace ".feature" with "_feature_test.mbt"
pub fn feature_to_test_filename(path : String) -> String {
  let mut result = path
  if starts_with(result, "features/") {
    result = substring_from(result, 9) // len("features/") == 9
  }
  result = string_replace(result, "/", "_")
  result = string_replace(result, ".feature", "_feature_test.mbt")
  result
}

///|
/// Generate a MoonBit test file from a Gherkin feature file.
///
/// Produces `async test` blocks for each scenario, with a header comment
/// containing the source path and a content hash for staleness detection.
pub fn generate_test_file(
  feature_content : String,
  source_path : String,
) -> String {
  let hash = simple_hash(feature_content)
  let source = @gherkin.Source::from_string(feature_content)
  let doc = try {
    @gherkin.parse!(source)
  } catch {
    _ =>
      return (
        "// moonspec:hash:" + hash + "\n// ERROR: Failed to parse " + source_path +
        "\n"
      )
  }
  let buf = StringBuilder::new()
  // Header
  buf.write_string("// Generated by moonspec codegen — DO NOT EDIT\n")
  buf.write_string("// Source: " + source_path + "\n")
  buf.write_string("// moonspec:hash:" + hash + "\n")
  buf.write_string("\n")
  let feature = match doc.feature {
    Some(f) => f
    None => return buf.to_string()
  }
  let feature_name = feature.name
  // Iterate children
  for child in feature.children {
    match child {
      @gherkin.FeatureChild::Scenario(scenario) => {
        if scenario.examples.is_empty() {
          // Regular scenario — one async test block
          generate_scenario_test(
            buf, feature_name, scenario.name, source_path, scenario.steps,
          )
          buf.write_string("\n")
        } else {
          // Scenario Outline — one test per Examples row
          let template_steps = scenario.steps
          for examples in scenario.examples {
            let headers = match examples.table_header {
              Some(header_row) => header_row.cells.map(fn(c) { c.value })
              None => continue
            }
            let rows = examples.table_body.map(fn(r) {
              r.cells.map(fn(c) { c.value })
            })
            for row in rows {
              // Build parameter suffix
              let params : Array[String] = []
              for i = 0; i < headers.length(); i = i + 1 {
                params.push(headers[i] + "=" + row[i])
              }
              let scenario_name =
                scenario.name + " (" + params.join(", ") + ")"
              generate_scenario_test_with_expanded(
                buf, feature_name, scenario_name, source_path, template_steps,
                headers, row,
              )
              buf.write_string("\n")
            }
          }
        }
      }
      _ => () // Background, Rule — skip for test generation
    }
  }
  buf.to_string()
}

///|
/// Generate a single async test block for a scenario.
fn generate_scenario_test(
  buf : StringBuilder,
  feature_name : String,
  scenario_name : String,
  source_path : String,
  steps : Array[@gherkin.Step],
) -> Unit {
  let test_name =
    "Feature: " + feature_name + " / Scenario: " + scenario_name
  buf.write_string("async test \"" + escape_string(test_name) + "\" {\n")
  buf.write_string("  // Source: " + source_path + "\n")
  for step in steps {
    let keyword = trim_trailing_spaces(step.keyword)
    buf.write_string("  // " + keyword + " " + step.text + "\n")
  }
  buf.write_string("  ignore(\"\")\n")
  buf.write_string("}\n")
}

///|
/// Generate a single async test block for an expanded scenario outline row.
fn generate_scenario_test_with_expanded(
  buf : StringBuilder,
  feature_name : String,
  scenario_name : String,
  source_path : String,
  steps : Array[@gherkin.Step],
  headers : Array[String],
  row : Array[String],
) -> Unit {
  let test_name =
    "Feature: " + feature_name + " / Scenario: " + scenario_name
  buf.write_string("async test \"" + escape_string(test_name) + "\" {\n")
  buf.write_string("  // Source: " + source_path + "\n")
  for step in steps {
    let keyword = trim_trailing_spaces(step.keyword)
    let mut text = step.text
    for i = 0; i < headers.length(); i = i + 1 {
      text = string_replace(text, "<" + headers[i] + ">", row[i])
    }
    buf.write_string("  // " + keyword + " " + text + "\n")
  }
  buf.write_string("  ignore(\"\")\n")
  buf.write_string("}\n")
}

///|
/// Remove trailing spaces from a string.
fn trim_trailing_spaces(s : String) -> String {
  let chars = s.to_array()
  let mut end = chars.length()
  while end > 0 && chars[end - 1] == ' ' {
    end = end - 1
  }
  if end == chars.length() {
    return s
  }
  let buf = StringBuilder::new()
  for i = 0; i < end; i = i + 1 {
    buf.write_char(chars[i])
  }
  buf.to_string()
}

///|
/// Escape double quotes in a string for use inside a MoonBit string literal.
fn escape_string(s : String) -> String {
  string_replace(s, "\"", "\\\"")
}
