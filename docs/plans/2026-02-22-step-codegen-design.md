# Compile-Time Attribute Scanning CLI for Step Definition Codegen

**Issue:** moonspec-sgg
**Date:** 2026-02-22
**Status:** Design approved

## Summary

Add `moonspec gen steps` to scan MoonBit source files for `#moonspec.*` custom attributes and generate `register_steps` implementations automatically. Delivered as an epic in 3 phases alongside a CLI refactoring and hierarchical config system.

## Epic Structure

### Phase 1: CLI Refactoring

Rename `moonspec gen` to `moonspec gen tests`. Add `moonspec gen steps` (stub). Bare `moonspec gen` without subcommand shows help — clean break, no deprecation path (pre-1.0).

### Phase 2: Hierarchical Config Package

New `src/config/` package with moonspec-specific hierarchical config loading.

### Phase 3: Attribute Scanning & Step Codegen

Using `moonbitlang/parser` (v0.1.16) to parse `.mbt` files and extract `#moonspec.*` attributes from the AST.

---

## Config Design

### File: `moonspec.json5`

Placed at two levels:
- **Module level** (next to `moon.mod.json`) — defaults for the whole module
- **Package level** (next to `moon.pkg.json`) — overrides for that package

Package-level fields override module-level. Missing fields inherit from parent.

### Schema

```json5
{
  // World type name (used by gen tests)
  "world": "MyWorld",

  // Codegen mode — simple string or per-feature map
  // Simple form:
  "mode": "per-scenario",
  // Map form (keys are relative paths or globs):
  "mode": {
    "features/checkout.feature": "per-feature",
    "features/cart*.feature": "per-scenario",
    "*": "per-scenario"
  },

  // Step codegen settings (used by gen steps)
  "steps": {
    // Output location mode:
    //   "generated"   — _generated/steps.mbt directory (default)
    //   "alongside"   — <world>_steps_gen.mbt next to source files
    //   "per-package"  — one moonspec_gen.mbt per package
    //   <custom path> — user-specified path
    "output": "generated",

    // Glob patterns for packages/files to skip when scanning
    "exclude": ["lib/*"]
  }
}
```

### Glob Matching

For `mode` map keys and `exclude` patterns. Check `moonbitlang/core` and `moonbitlang/x` first for glob support. Fall back to `justjavac/glob` or create `moonrockz/glob` if needed.

---

## Attribute Scanning (Phase 3)

### Target Developer Experience

#### Methods with self:
```moonbit
struct MyWorld { mut cucumbers : Int } derive(Default)

#moonspec.given("I have {int} cucumbers")
fn set_cucumbers(self : MyWorld, count : Int) -> Unit {
  self.cucumbers = count
}
```

#### Standalone functions:
```moonbit
#moonspec.when("I eat {int} cucumbers")
fn eat_cucumbers(world : MyWorld, count : Int) -> Unit {
  world.cucumbers = world.cucumbers - count
}
```

#### Custom constructor:
```moonbit
#moonspec.world(init = Self::new)
struct AnimalWorld { mut cat : Cat }
```

### Scanning Pipeline

1. **Discover** `.mbt` files in all packages (minus `steps.exclude` globs from config)
2. **Parse** each file with `@parser.parse_file()`
3. **Walk** `List[Impl]` looking for:
   - `TopTypeDef` with `#moonspec.world(init = ...)` on structs
   - `TopFuncDef` with `#moonspec.given/when/then("pattern")` on functions
4. **Group** step functions by World type (from `self` param type or first param type)
5. **Generate** `register_steps` implementation per World type

### AST Access

The `moonbitlang/parser` AST provides:

- `FunDecl.attrs : List[Attribute]` — custom attributes on functions
- `TypeDecl.attrs : List[Attribute]` — custom attributes on types
- `Attribute.parsed` — structured `Expr` with namespace (`moonspec`), name (`given`), and arguments
- `FunDecl.decl_params` — full parameter list with types
- `FunDecl.name` — function name

For `#moonspec.given("I have {int} cucumbers")`, the parsed attribute is:
```
Apply(Id { qual: Some("moonspec"), name: "given" }, [Expr(String("I have {int} cucumbers"))])
```

### Generated Output

For the input above, generates:
```moonbit
// Generated by moonspec gen steps — DO NOT EDIT
// moonspec:hash:XXXXXXXX

impl @moonspec.World for MyWorld with register_steps(self, s) {
  s.given("I have {int} cucumbers", fn(args) {
    set_cucumbers(self, args[0].to_int())
  })
  s.when("I eat {int} cucumbers", fn(args) {
    eat_cucumbers(self, args[0].to_int())
  })
  s.then("I should have {int} cucumbers", fn(args) raise {
    check_cucumbers(self, args[0].to_int())
  })
}
```

### Argument Mapping

Function parameter types map to `StepArg` extraction:
- `Int` → `args[n].to_int()`
- `String` → `args[n].to_string()`
- `Double` → `args[n].to_float()`

The `self`/world parameter is skipped (index 0); cucumber expression arguments start at parameter index 1.

### Custom Constructor

When `#moonspec.world(init = Self::new)` is found on a struct, the generated test factory uses `MyWorld::new` instead of `MyWorld::default`.

### Conflict Detection

Before writing, scan source files for manual `impl World for X with register_steps` blocks. If found, emit a warning and skip generation for that World type.

### Staleness

Reuse the existing FNV-1a hash approach from feature codegen. Hash the scanned source content, embed as `// moonspec:hash:XXXXXXXX` in generated file headers. Skip regeneration when hash matches.

---

## Dependencies

- `moonbitlang/parser` (v0.1.16) — MoonBit source parser
- Glob library (TBD: check core/x first, then `justjavac/glob` or `moonrockz/glob`)

## Function Style Support

Both method-style (`self : MyWorld`) and standalone (`world : MyWorld`) functions are supported. World type is inferred from:
- Methods: the type of `self`
- Standalone: the type of the first parameter
