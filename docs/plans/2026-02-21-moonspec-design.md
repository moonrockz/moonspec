# moonspec — BDD Test Framework for MoonBit

**Date:** 2026-02-21
**Package:** `moonrockz/moonspec`
**Repo:** `moonspec.mbt` (GitHub)
**Status:** Approved

## Overview

moonspec is a full-featured BDD (Behavior-Driven Development) test framework for MoonBit, inspired by [godog](https://github.com/cucumber/godog), [behave](https://github.com/behave/behave), and [cucumber-rs](https://github.com/cucumber-rs/cucumber). It parses Gherkin `.feature` files, matches steps via Cucumber Expressions, and executes scenarios against user-defined step implementations.

## Dependencies

- `moonrockz/gherkin` — Gherkin parser (existing, v0.3.0)
- `moonrockz/cucumber-messages` — Cucumber Messages protocol types (existing, v0.1.0)
- `moonrockz/cucumber-expressions` — Cucumber Expression matching (new, designed alongside)

## Architecture

```
.feature files ──→ moonrockz/gherkin (parse) ──→ GherkinDocument
                                                       │
                                                       ▼
                   moonrockz/cucumber-expressions ◄── moonspec/core
                   (pattern matching)                  (World, Steps, Registry)
                                                       │
                                                       ▼
                                                  moonspec/runner
                                                  (execute scenarios)
                                                       │
                                               ┌───────┼───────┐
                                               ▼       ▼       ▼
                                            /format /codegen  /cmd
                                            (pretty  (gen     (CLI
                                             msgs    _test.mbt) entry)
                                             junit)
```

## Package Structure

```
moonspec/
  src/
    core/
      world.mbt           — World trait
      steps.mbt            — Steps trait, StepRegistry
      hooks.mbt            — Hooks trait (before/after scenario/step)
      types.mbt            — StepArg, StepHandler, ScenarioInfo, StepInfo
    runner/
      runner.mbt           — Runner struct, execution orchestration
      lifecycle.mbt        — Scenario lifecycle (setup, execute, teardown)
      parallel.mbt         — Parallel scenario execution
      tags.mbt             — Tag expression parser and matcher
      results.mbt          — StepStatus, StepResult, ScenarioResult, RunResult
    format/
      formatter.mbt        — Formatter trait
      pretty.mbt           — Colored console output
      messages.mbt         — Cucumber Messages NDJSON output
      junit.mbt            — JUnit XML output
    codegen/
      codegen.mbt          — _test.mbt file generation from .feature files
    cmd/
      main/
        main.mbt           — CLI entry point
  moon.mod.json
  moon.pkg.json
```

## Integration Modes

moonspec supports three ways to run BDD tests:

### 1. Code Generation (Primary)

`moonspec gen` produces `_test.mbt` files from `.feature` files. Each scenario becomes a `test` block that `moon test` discovers natively.

```moonbit
// Generated by moonspec — do not edit
// Source: features/login.feature

test "Feature: User Login / Scenario: Valid credentials" {
  let runner = @moonspec.Runner::new(@myapp.MyWorld::new())
  runner.run_scenario!(
    feature="features/login.feature",
    scenario="Valid credentials",
  )
}
```

Can be wired as a pre-build hook in `moon.pkg.json`:
```json
{ "pre-build": ["moonspec gen"] }
```

### 2. Runner API

Call directly inside a `test` block for maximum simplicity:

```moonbit
test "BDD: login feature" {
  moonspec.run!(MyWorld::new(), "features/login.feature")
}
```

Runs all scenarios in the feature. Raises `Error` on any failure.

### 3. Standalone CLI

`moonspec run` parses, generates, and executes in one step:

```
$ moonspec run features/
```

## Core API Design

### World Trait

```moonbit
pub(open) trait World {
  new() -> Self
}
```

User implements this with their domain state. A fresh instance is created per scenario.

### Steps Trait

```moonbit
pub(open) trait Steps {
  steps(Self, StepRegistry) -> Unit
}
```

User implements to register step definitions:

```moonbit
struct MyWorld {
  mut cucumbers : Int
}

impl Steps for MyWorld with {
  steps(self, s : StepRegistry) {
    s.given("I have {int} cucumbers", fn(count) { self.cucumbers = count })
    s.when("I eat {int} cucumbers", fn(count) { self.cucumbers -= count })
    s.then("I should have {int} cucumbers", fn(count) {
      assert_eq!(self.cucumbers, count)
    })
  }
}
```

### Hooks Trait

```moonbit
pub(open) trait Hooks {
  before_scenario(Self, ScenarioInfo) -> Unit!Error
  after_scenario(Self, ScenarioInfo, Result) -> Unit!Error
  before_step(Self, StepInfo) -> Unit!Error
  after_step(Self, StepInfo, Result) -> Unit!Error
}
```

All hooks have default no-op implementations.

### Step Matching

Step text is matched against registered Cucumber Expressions via `moonrockz/cucumber-expressions`. Parameters are extracted as typed `StepArg` values:

```moonbit
pub enum StepArg {
  IntArg(Int)
  FloatArg(Double)
  StringArg(String)
  WordArg(String)
  CustomArg(String)
}
```

Regex fallback is supported for complex patterns.

## Runner Design

### Configuration

```moonbit
pub struct RunConfig {
  tags : String?
  parallel : Bool
  dry_run : Bool
  formatters : Array[Formatter]
}
```

### Execution Lifecycle (per scenario)

1. `W::new()` — fresh World instance
2. `world.steps(registry)` — register step definitions
3. `hooks.before_scenario(info)`
4. For each step:
   a. Match step text against registry via cucumber-expressions
   b. Extract parameters as `Array[StepArg]`
   c. `hooks.before_step(info)`
   d. Execute handler with `(world, args)`
   e. `hooks.after_step(info, result)`
   f. On failure: mark remaining steps as `Skipped`
5. `hooks.after_scenario(info, result)`
6. Notify formatters

### Result Types

```moonbit
pub enum StepStatus {
  Passed
  Failed(Error)
  Skipped
  Undefined
  Pending
}

pub struct StepResult {
  step : Step
  status : StepStatus
  duration : Duration
}

pub struct ScenarioResult {
  scenario : Scenario
  steps : Array[StepResult]
  status : ScenarioStatus
  duration : Duration
}

pub struct RunResult {
  features : Array[FeatureResult]
  summary : RunSummary
}
```

### Tag Filtering

Boolean tag expressions:

```
@smoke                → has tag @smoke
not @slow             → doesn't have @slow
@smoke and not @slow  → intersection
@fast or @critical    → union
```

```moonbit
pub fn TagExpression::parse(expr : String) -> TagExpression!Error
pub fn TagExpression::matches(self, tags : Array[Tag]) -> Bool
```

### Scenario Outline Expansion

Scenario Outlines with Examples tables are expanded into concrete scenarios before execution. Each Examples row produces one scenario. Generated test names include parameter values for uniqueness:

```
test "Feature: X / Scenario: eating (start=12, eat=5, left=7)"
```

## Formatters

### Formatter Trait

```moonbit
pub(open) trait Formatter {
  on_run_start(Self, RunInfo) -> Unit
  on_feature_start(Self, Feature) -> Unit
  on_scenario_start(Self, Scenario) -> Unit
  on_step_finish(Self, StepResult) -> Unit
  on_scenario_finish(Self, ScenarioResult) -> Unit
  on_feature_finish(Self, FeatureResult) -> Unit
  on_run_finish(Self, RunResult) -> Unit
}
```

Formatters are event-driven (push). The runner notifies all registered formatters as events happen.

### Pretty Formatter

Colored, indented console output with pass/fail markers, durations, and summary counts.

### Messages Formatter

NDJSON output using `moonrockz/cucumber-messages`. Maps runner events to Envelope types. Enables integration with any Cucumber ecosystem tool.

### JUnit Formatter

Standard JUnit XML for CI systems. Buffers results internally, writes XML on `on_run_finish`.

## CLI

```
moonspec <command> [options]

Commands:
  run       Parse, generate, and execute features
  gen       Generate _test.mbt files from .feature files
  check     Validate step bindings (dry-run)
  list      List scenarios, optionally filtered by tags
  fmt       Format .feature files

Global options:
  --features <dir>    Features directory (default: features/)
  --tags <expr>       Tag filter expression
  --format <name>     Output format: pretty, messages, junit (default: pretty)
  --no-color          Disable ANSI colors
```

## Code Generation

### Input/Output Mapping

- `features/login.feature` → `login_feature_test.mbt`
- `features/admin/users.feature` → `admin_users_feature_test.mbt`

### Staleness Detection

Generated files include a header comment with a hash of the source `.feature` file. `moonspec gen` skips regeneration if the hash matches.

## Design Principles

- **ADTs** — model domain precisely with sum and product types
- **Make invalid states unrepresentable**
- **Total functions** — `Result`/`Option` over panicking
- **Immutability by default** — `mut` only when necessary
- **Pattern matching over conditionals**
- **TDD** — red-green-refactor with snapshot testing
- **Composition over inheritance**
